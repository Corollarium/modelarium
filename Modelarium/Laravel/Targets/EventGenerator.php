<?php declare(strict_types=1);

namespace Modelarium\Laravel\Targets;

use GraphQL\Type\Definition\NonNull;
use GraphQL\Type\Definition\ObjectType;
use GraphQL\Type\Definition\Type;
use Modelarium\BaseGenerator;
use Modelarium\GeneratedCollection;
use Modelarium\GeneratedItem;
use Modelarium\Parser;
use Nette\PhpGenerator\ClassType;

class EventGenerator extends BaseGenerator
{
    /**
     * @var string
     */
    protected $stubDir = __DIR__ . "/stubs/";

    /**
     * @var ObjectType
     */
    protected $type = null;

    /**
     * @var GeneratedCollection
     */
    protected $events;

    public function generate(): GeneratedCollection
    {
        $this->events = new GeneratedCollection();

        foreach ($this->type->getFields() as $field) {
            $directives = $field->astNode->directives;
            $this->processFieldDirectives($field, $directives, 'Event');
        }
        return $this->events;
    }

    protected function makeEventClass(string $name, string $model): GeneratedItem
    {
        list($eventNamespace, $eventClassName, $relativePath) = $this->splitClassName($name);

        $namespace = new \Nette\PhpGenerator\PhpNamespace($eventNamespace);

        /**
         * @var ClassType $class
         */
        $class = $namespace->addClass($eventClassName);
        $class
            ->addComment("This file was automatically generated by Modelarium.")
            ->setTraits(['Illuminate\Queue\SerializesModels']);
        
        $class->addProperty('target')
            ->setPublic()
            ->setComment("@var $model");
        $printer = new \Nette\PhpGenerator\PsrPrinter;
    
        $constructor = $class->addMethod('__construct');
        $constructor->setPublic()
            ->addParameter('target')
            ->setType('App\\Models\\' . $model);

        $constructor->addBody(
            '$this->target = $target;'
        );

        return new GeneratedItem(
            $name,
            "<?php declare(strict_types=1);\n\n" . $printer->printNamespace($namespace),
            $this->getGenerateFilename($relativePath, $eventClassName)
        );
    }

    /**
     * @param \GraphQL\Type\Definition\FieldDefinition $field
     * @param \GraphQL\Language\AST\NodeList<\GraphQL\Language\AST\DirectiveNode> $directives
     * @param string $type
     * @return void
     */
    public function processFieldDirectives(
        \GraphQL\Type\Definition\FieldDefinition $field,
        \GraphQL\Language\AST\NodeList $directives,
        string $type
    ): void {
        // TODO: there's probably no need to override this
        if ($field->getType() instanceof NonNull) {
            $type = $field->getType()->getWrappedType();
        } else {
            $type = $field->getType();
        }
        $typeName = $type->name;
        
        foreach ($directives as $directive) {
            $name = $directive->name->value;
            switch ($name) {
            case 'event':
                $dispatch = Parser::getDirectiveArgumentByName($directive, 'dispatch');
                $e = $this->makeEventClass($dispatch, $typeName);
                $this->events->push($e);
                break;
            default:
            }
        }
    }

    public function getGenerateFilename(string $relativePath, string $name): string
    {
        // fix App -> app
        if (mb_substr($relativePath, 0, 3) === 'App' && !is_dir($this->getBasePath($relativePath))) {
            $relativePath[0] = 'a';
        }
        return $this->getBasePath($relativePath . '/' . $name . '.php');
    }
}
